# https://leetcode.com/problems/rearrange-characters-to-make-target-string/

class Solution:
    def rearrangeCharacters(self, s: str, target: str) -> int:
        
        dictar = {}
        for i in target:
            if i not in dictar:
                dictar[i]=0
            dictar[i]+=1
        
        dics = {}
        for i in s:
            if i in dictar:
                if i not in dics:
                    dics[i]=0
                dics[i]+=1
        
        if set(dictar)!=set(dics):
            return 0
        
        minfactor = float(inf)
        for c in dics:
            factor = dics[c]//dictar[c]
            if factor < minfactor:
                minfactor = factor
        
        return minfactor


# https://leetcode.com/problems/max-points-on-a-line/

class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        if len(points)==1:
	        return 1
        
        arr = [((p[0],p[1]),(q[0],q[1])) for ind,p in enumerate(points) for q in points[ind+1:]]
        
        dic = {}
        for (x1,y1),(x2,y2) in arr:
            if x1==x2:
                a = 'inf'
                b = x1
            elif y1==y2:
                a = 0
                b = y1
            else:
                from fractions import Fraction
                a = Fraction((y2-y1),(x2-x1))
                b = y1 - a*x1
            if (a,b) not in dic:
                dic[(a,b)]=0
            dic[(a,b)]+=1
        
        # k = (n*(n-1))/2
        ans = (1 + (1+8*max(dic.values()))**(1/2)) / 2
        return int(ans)



# https://leetcode.com/problems/maximum-number-of-visible-points/

class Solution:
    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:
        
        if len(points)==1:
            return 1

        from math import pi, atan

        angle = angle*pi/180

        i, j = location[0], location[1]
        for k in range(len(points)):
            x, y = points[k]
            points[k] = [x-i, y-j]

        # угол между point и [1,0]
        temp = []
        for k in range(len(points)):
            x, y = points[k]
            if x!=0 or y!=0:
                if x>0:
                    if y>=0:
                        temp.append(atan(y/x))
                    else:
                        temp.append(2*pi+atan(y/x))
                elif x==0:
                    if y>0:
                        temp.append(pi/2)
                    else:
                        temp.append(3*pi/2)
                elif x<0:
                    temp.append(pi+atan(y/x))

        temp.sort()
        
        duplicate = []
        for k in range(len(temp)):
            duplicate.append(temp[k]+2*pi)
        temp.extend(duplicate)

        maxnum = 0
        i, j = 0, 0
        while j<len(temp):
            if temp[j]-temp[i] <= angle:
                maxnum = max(maxnum, j-i+1)
                j+=1
            else:
                if i==j:
                    j+=1
                else:
                    i+=1

        return maxnum + points.count([0,0])



# https://leetcode.com/problems/movie-rating/?envType=study-plan-v2&envId=top-sql-50

SELECT K1.name results FROM 
    (SELECT T1.name, COUNT(T1.movie_id) nums_of_rat FROM 
        (SELECT Users.name name, MovieRating.movie_id movie_id, MovieRating.created_at created_at FROM Users INNER JOIN MovieRating ON Users.user_id=MovieRating.user_id) T1 
     GROUP BY T1.name 
     ORDER BY nums_of_rat DESC, name 
     LIMIT 1) K1
UNION ALL
SELECT K2.title FROM 
    (SELECT T2.title, AVG(T2.rat) avg_rat FROM 
        (SELECT Movies.title title, MovieRating.rating rat, MovieRating.created_at created_at FROM Movies INNER JOIN MovieRating ON Movies.movie_id=MovieRating.movie_id
         WHERE created_at LIKE '2020-02-__') T2 
     GROUP BY T2.title 
     ORDER BY avg_rat DESC, title 
     LIMIT 1) K2

